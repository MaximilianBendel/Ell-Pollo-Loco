<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: models/07_world.class.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: models/07_world.class.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Represents the game world.
 */
class World {
    character = new Character();
    statusbar = new Statusbar();
    coinbar = new Coinbar();
    bottlebar = new Bottlebar();
    endbossbar = new Endbossbar();
    enemies = level1.enemies;
    clouds = level1.clouds;
    BackGroundObjects = level1.BackGroundObjects;
    level = level1;
    bottle = [];
    collectableBottles = level1.collectableBottles;
    collectableCoins = level1.collectableCoins;
    WinEndScreen = document.getElementById('WinScreenEnd');
    LoseEndScreen = document.getElementById('LoseScreenEnd');
    canvas = document.getElementById('canvas');
    ctx;
    keyboard;
    camera_x = 0;
    lastThrowTime = 0;
    winScreen = false;
    loseScreen = false;
    runInterval = true;

    /**
     * Creates an instance of World.
     * @param {HTMLCanvasElement} canvas - The canvas element.
     * @param {Keyboard} keyboard - The keyboard object for game controls.
     */
    constructor(canvas, keyboard) {
        this.ctx = canvas.getContext('2d');
        this.canvas = canvas;
        this.keyboard = keyboard;
        this.initializeBackgroundObjects();
        this.draw();
        this.setWorld();
        this.setEndboss();
        this.run();
    }

    /**
     * Connects the character with the world.
     */
    setWorld() {
        this.character.world = this;
    }

    /**
     * Sets the endboss and connects it with the character.
     */
    setEndboss() {
        this.enemies.forEach(enemy => {
            if (enemy instanceof Endboss) {
                enemy.character = this.character;
            }
        });
    }

    /**
     * Initializes the background objects in the level.
     */
    initializeBackgroundObjects() {
        const layers = [
            'img_pollo_locco/img/5_background/layers/air.png',
            'img_pollo_locco/img/5_background/layers/air.png',
            'img_pollo_locco/img/5_background/layers/3_third_layer/1.png',
            'img_pollo_locco/img/5_background/layers/3_third_layer/2.png',
            'img_pollo_locco/img/5_background/layers/2_second_layer/1.png',
            'img_pollo_locco/img/5_background/layers/2_second_layer/2.png',
            'img_pollo_locco/img/5_background/layers/1_first_layer/1.png',
            'img_pollo_locco/img/5_background/layers/1_first_layer/2.png'
        ];
        const startPositions = [-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
        startPositions.forEach(position => {
            for (let j = 0; j &lt; layers.length; j += 2) {
                this.BackGroundObjects.push(new BackGroundObject(layers[j], position * 719 * 2));
                this.BackGroundObjects.push(new BackGroundObject(layers[j + 1], position * 719 * 2 + 719));
            }
        });
    }

    /**
     * Starts the main game loop, checking for collisions and other game events.
     */
    run() {
        if (this.runInterval) clearInterval(this.runInterval);
        this.runInterval = setInterval(() => {
            this.checkThrowObject();
            this.checkEnemyCollisionWithBottle();
            this.checkCollisionsWithCollectableBottles();
            this.checkCollisionsWithCollectableCoins();
            this.checkEndbossTrigger();
            this.checkBottleHitGround();
            this.updateEndbossBar();
            this.handleDeadEnemies();
            this.checkIfWin();
            this.checkIfLose();
            this.updateEndbossMovement();
        }, 25);
        this.checkCollisionsCharacter();
    }

    /**
     * Updates the movement of the endboss.
     */
    updateEndbossMovement() {
        this.enemies.forEach(enemy => {
            if (enemy instanceof Endboss &amp;&amp; enemy.animationTriggered) {
                enemy.followCharacter();
            }
        });
    }

    /**
     * Checks if a throwable object should be thrown.
     */
    checkThrowObject() {
        const currentTime = Date.now();
        if ((this.keyboard.F || this.keyboard.THROW_BTN || this.keyboard.C) &amp;&amp; currentTime - this.lastThrowTime >= 2000 &amp;&amp; this.bottlebar.bottles > 0) {
            this.bottle.push(new ThrowableObject(this.character.x + 50, this.character.y + 100, this.character.direction));
            this.bottlebar.setBottles(--this.bottlebar.bottles);
            this.lastThrowTime = currentTime;
        }
    }

    /**
     * Checks for collisions between enemies and thrown bottles.
     */
    checkEnemyCollisionWithBottle() {
        this.enemies.forEach(enemy => {
            this.bottle.forEach((bottle, index) => {
                if (bottle.isColliding(enemy)) {
                    if (enemy instanceof Chicken || enemy instanceof brownChicken) {
                        this.handleChickenHit(enemy, bottle, index);
                    } else if (enemy instanceof Endboss &amp;&amp; enemy.notHurtable) {
                        this.handleEndbossHit(enemy, bottle, index);
                    }
                }
            });
        });
    }

    /**
     * Handles the collision of a chicken with a bottle.
     * @param {Chicken|brownChicken} enemy - The colliding chicken.
     * @param {ThrowableObject} bottle - The colliding bottle.
     */
    handleChickenHit(enemy, bottle) {
        if (!enemy.isHitCooldown) {
            enemy.hit(100);
            bottle.bottleSplash();
            if (enemy.lifepoints &lt;= 0) {
                enemy.deadAnimation(enemy);
            }
        }
    }

    /**
     * Handles the collision of the endboss with a bottle.
     * @param {Endboss} enemy - The colliding endboss.
     * @param {ThrowableObject} bottle - The colliding bottle.
     */
    handleEndbossHit(enemy, bottle) {
        if (!enemy.isHitCooldown) {
            enemy.hit(20);
            enemy.isHurtAnimation();
            bottle.bottleSplash();
        }
    }

    /**
     * Checks if the bottle has hit the ground.
     */
    checkBottleHitGround() {
        this.bottle.forEach((bottle, index) => {
            if (bottle.y >= 350) {
                if (!this.isBottleCollidingWithEnemy(bottle)) {
                    bottle.playGlasSplashSound();
                }
                bottle.bottleSplash();
                this.removeBottleAfterDelay(index);
            }
        });
    }

    /**
     * Checks if a bottle is colliding with an enemy.
     * @param {ThrowableObject} bottle - The bottle to check.
     * @returns {boolean} - Returns true if a collision occurs, otherwise false.
     */
    isBottleCollidingWithEnemy(bottle) {
        return this.enemies.some(enemy => bottle.isColliding(enemy));
    }

    /**
     * Removes the bottle after a delay.
     * @param {number} index - The index of the bottle to remove.
     */
    removeBottleAfterDelay(index) {
        setTimeout(() => this.bottle.splice(index, 1), 250);
    }

    /**
     * Checks for collisions with collectable bottles.
     */
    checkCollisionsWithCollectableBottles() {
        this.collectableBottles?.forEach(bottle => {
            if (this.character.isColliding(bottle)) {
                bottle.collectBottle(this.collectableBottles, this.bottlebar);
            }
        });
    }

    /**
     * Checks for collisions with collectable coins.
     */
    checkCollisionsWithCollectableCoins() {
        this.collectableCoins?.forEach(coin => {
            if (this.character.isColliding(coin)) {
                coin.collectCoin(this.collectableCoins, this.coinbar);
            }
        });
    }

    /**
     * Checks if the endboss should be triggered.
     */
    checkEndbossTrigger() {
        if (this.character.x > 5450) {
            this.enemies.forEach(enemy => {
                if (enemy instanceof Endboss &amp;&amp; !enemy.animationTriggered) {
                    enemy.startAnimation();
                    enemy.animationTriggered = true;
                }
            });
        }
    }

    /**
     * Updates the health bar of the endboss.
     */
    updateEndbossBar() {
        this.level.enemies.forEach(enemy => {
            if (enemy instanceof Endboss) {
                this.endbossbar.setPercentage(enemy.lifepoints);
            }
        });
    }

    /**
     * Removes dead enemies from the game.
     */
    handleDeadEnemies() {
        this.enemies = this.enemies.filter(enemy => !enemy.isDead);
    }

    /**
     * Checks if the player has lost.
     */
    checkIfLose() {
        if (this.character.lifepoints &lt;= 0) {
            this.loseScreen = true;
            showMobileButtonsStatus = false;
            setTimeout(() => this.stoppAllAnimations(), 1500);
            setTimeout(() => {
                soundManager.pauseSound('gamemusic');
                soundManager.playnormalSound('loselevel');
                this.showLoseScreenEnd();
            }, 2500);
        }
    }

    /**
     * Shows the lose screen.
     */
    showLoseScreenEnd() {
        this.canvas.classList.remove('display-block');
        this.LoseEndScreen.style.display = 'block';
    }

    /**
     * Checks if the player has won.
     */
    checkIfWin() {
        if (this.enemies.some(enemy => enemy instanceof Endboss &amp;&amp; enemy.lifepoints &lt;= 0)) {
            this.winScreen = true;
            showMobileButtonsStatus = false;
            setTimeout(() => this.stoppAllAnimations(), 1500);
            setTimeout(() => {
                soundManager.pauseSound('gamemusic');
                soundManager.playnormalSound('winlevel');
                this.showWinScreenEnd();
            }, 2500);
        }
    }

    /**
     * Stops all animations in the game.
     */
    stoppAllAnimations() {
        this.winScreen = true;
        this.enemies.forEach(enemy => enemy.stopAllAnimations());
        this.character.stoppAllAnimations();
        clearInterval(this.runInterval);
        this.runInterval = false;
    }

    /**
     * Shows the win screen.
     */
    showWinScreenEnd() {
        this.canvas.classList.remove('display-block');
        this.WinEndScreen.style.display = 'block';
    }

    /**
     * Checks for character collisions with enemies and the endboss.
     */
    checkCollisionsCharacter() {
        setInterval(() => {
            this.checkCollisionsWithChicken();
            this.checkCollisionsWithEndboss();
        }, 10);
    }

    /**
     * Checks for character collisions with chickens.
     */
    checkCollisionsWithChicken() {
        this.enemies.forEach(enemy => {
            if (enemy instanceof Chicken || enemy instanceof brownChicken) {
                if (this.character.speedY &lt; 0 &amp;&amp; this.character.isAboveGround() &amp;&amp; this.character.isColliding(enemy) &amp;&amp; (this.character.y + this.character.height - this.character.offsetHeight) &lt; (enemy.y + enemy.height / 2)) {
                    this.character.speedY = 17;
                    this.character.unHurtable();
                    enemy.hit(100);
                    if (enemy.lifepoints &lt;= 0) {
                        enemy.deadAnimation();
                    }
                } else if (enemy.lifepoints > 0 &amp;&amp; this.character.isColliding(enemy)) {
                    if (!this.character.CharacterIsUnhurtable) {
                        this.character.hit(5);
                        this.character.unHurtable();
                        this.statusbar.setPercentage(this.character.lifepoints);
                    }
                }
            }
        });
    }

    /**
     * Checks for character collisions with the endboss.
     */
    checkCollisionsWithEndboss() {
        this.enemies.forEach(enemy => {
            if (enemy instanceof Endboss &amp;&amp; !enemy.isAttacking &amp;&amp; enemy.isColliding(this.character)) {
                enemy.startAttack();
                this.character.hit(5);
                this.statusbar.setPercentage(this.character.lifepoints);
            }
        });
    }

    /**
     * Draws the game world.
     */
    draw() {
        if (this.isClearing || !this.ctx) return;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.translate(this.camera_x, 0);
        this.addObjectsToMap(this.BackGroundObjects);
        this.ctx.translate(-this.camera_x, 0);
        this.addObjectsToMap(this.clouds);
        this.addToMap(this.statusbar);
        this.addToMap(this.coinbar);
        this.addToMap(this.bottlebar);
        this.addToMap(this.endbossbar);
        this.ctx.translate(this.camera_x, 0);
        this.addToMap(this.character);
        this.addObjectsToMap(this.collectableCoins);
        this.addObjectsToMap(this.collectableBottles);
        this.addObjectsToMap(this.bottle);
        this.addObjectsToMap(this.enemies);
        this.ctx.translate(-this.camera_x, 0);
        requestAnimationFrame(() => this.draw());
    }

    /**
     * Adds a moveable object to the map.
     * @param {MoveableObject} movableObject - The object to add.
     */
    addToMap(movableObject) {
        if ((movableObject instanceof Character || movableObject instanceof Endboss) &amp;&amp; movableObject.direction === 'left') {
            this.ctx.save();
            this.ctx.scale(-1, 1);
            this.ctx.drawImage(movableObject.img, -movableObject.x - movableObject.width, movableObject.y, movableObject.width, movableObject.height);
            this.ctx.restore();
        } else {
            movableObject.draw(this.ctx);
        }
        if (typeof movableObject.drawFrame === 'function') {
            movableObject.drawFrame(this.ctx);
        }
    }

    /**
     * Adds a list of objects to the map.
     * @param {Array&lt;MoveableObject>} objects - The objects to add.
     */
    addObjectsToMap(objects) {
        objects.forEach(object => this.addToMap(object));
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BackGroundObject.html">BackGroundObject</a></li><li><a href="Bottlebar.html">Bottlebar</a></li><li><a href="Character.html">Character</a></li><li><a href="Chicken.html">Chicken</a></li><li><a href="Cloud.html">Cloud</a></li><li><a href="Coinbar.html">Coinbar</a></li><li><a href="Coins.html">Coins</a></li><li><a href="CollectableBottles.html">CollectableBottles</a></li><li><a href="DrawableObject.html">DrawableObject</a></li><li><a href="Endboss.html">Endboss</a></li><li><a href="Endbossbar.html">Endbossbar</a></li><li><a href="Keyboard.html">Keyboard</a></li><li><a href="Level.html">Level</a></li><li><a href="MoveableObject.html">MoveableObject</a></li><li><a href="SoundManager.html">SoundManager</a></li><li><a href="Statusbar.html">Statusbar</a></li><li><a href="ThrowableObject.html">ThrowableObject</a></li><li><a href="WinScreen.html">WinScreen</a></li><li><a href="World.html">World</a></li><li><a href="brownChicken.html">brownChicken</a></li></ul><h3>Global</h3><ul><li><a href="global.html#checkOrientation">checkOrientation</a></li><li><a href="global.html#closeInfoBox">closeInfoBox</a></li><li><a href="global.html#closeKeyboardMenu">closeKeyboardMenu</a></li><li><a href="global.html#controlMobileButtons">controlMobileButtons</a></li><li><a href="global.html#hideMobileButtons">hideMobileButtons</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initLevel">initLevel</a></li><li><a href="global.html#loadBackGroundMusic">loadBackGroundMusic</a></li><li><a href="global.html#loadBottleSounds">loadBottleSounds</a></li><li><a href="global.html#loadCharacterSounds">loadCharacterSounds</a></li><li><a href="global.html#loadChickenSounds">loadChickenSounds</a></li><li><a href="global.html#loadCollectSounds">loadCollectSounds</a></li><li><a href="global.html#loadEndScreenSounds">loadEndScreenSounds</a></li><li><a href="global.html#loadEndbossSounds">loadEndbossSounds</a></li><li><a href="global.html#loadMusic">loadMusic</a></li><li><a href="global.html#mobileEventListener">mobileEventListener</a></li><li><a href="global.html#openDatenschutz">openDatenschutz</a></li><li><a href="global.html#openImpressum">openImpressum</a></li><li><a href="global.html#openKeyboardMenu">openKeyboardMenu</a></li><li><a href="global.html#restartGame">restartGame</a></li><li><a href="global.html#showMobileButtons">showMobileButtons</a></li><li><a href="global.html#startGame">startGame</a></li><li><a href="global.html#toggleSound">toggleSound</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Tue Jul 16 2024 11:21:20 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
